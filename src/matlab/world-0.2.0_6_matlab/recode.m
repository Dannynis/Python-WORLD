[x, fs] = audioread('test-mwm.wav');lowest_f0=71;%fft_size = 2 ^ ceil(log2(length(y) + round(fs / lowest_f0 / 2) * 4)); %Low-cut filtering 2014/01/01%cutoff_in_sample = round(fs / 50); % Under 50 Hz will be cutted.%low_cut_filter = hanning(2 * cutoff_in_sample + 1);%low_cut_filter = -low_cut_filter / sum(low_cut_filter);%low_cut_filter(cutoff_in_sample + 1) = low_cut_filter(cutoff_in_sample + 1) + 1;%low_cut_filter = [low_cut_filter ; zeros(fft_size - length(low_cut_filter), 1)];%low_cut_filter =[low_cut_filter(cutoff_in_sample + 1 : end) ;...%  low_cut_filter(1 : cutoff_in_sample)];%y_spectrum = fft(y, fft_size) .* fft(low_cut_filter, fft_size);%negative_going_points =...%  (1 : length(x))' .*...%  (([x(2 : end) ; x(end)] .* x < 0) .* ([x(2 : end) ; x(end)] < x));  %edge_list = negative_going_points(negative_going_points > 0);%fine_edge_list = edge_list - x(edge_list) ./ (x(edge_list + 1) - x(edge_list));%event_struct.interval_locations =...%  (fine_edge_list(1 : end - 1) + fine_edge_list(2 : end)) / 2 / fs;%event_struct.interval_based_f0 = fs ./ diff(fine_edge_list);%disp(length(event_struct.interval_based_f0))%disp(length(event_struct.interval_locations))#N = 20;#t = (0 : N - 1)' * 2 * pi / (N - 1);#coefs = [0.355768; -0.487396; 0.144232; -0.012604];#window = cos(t * [0 1 2 3]) * coefs;function [interpolated_f0, f0_deviations] = GetF0Candidates(...  negative_zero_cross, positive_zero_cross, peak, dip, temporal_positions)usable_channel =...  max(0, length(negative_zero_cross.interval_locations) - 2) *...  max(0, length(positive_zero_cross.interval_locations) - 2) *...  max(0, length(peak.interval_locations) - 2) *...  max(0, length(dip.interval_locations) - 2);if usable_channel > 0  interpolated_f0_list = zeros(4, length(temporal_positions));  interpolated_f0_list(1, :) =...    interp1(negative_zero_cross.interval_locations,...    negative_zero_cross.interval_based_f0, temporal_positions,...    'linear', 'extrap');  interpolated_f0_list(2, :) =...    interp1(positive_zero_cross.interval_locations,...    positive_zero_cross.interval_based_f0, temporal_positions,...    'linear', 'extrap');  interpolated_f0_list(3, :) = interp1(peak.interval_locations,...    peak.interval_based_f0, temporal_positions, 'linear', 'extrap');  interpolated_f0_list(4, :) = interp1(dip.interval_locations,...    dip.interval_based_f0, temporal_positions, 'linear', 'extrap');    interpolated_f0 = mean(interpolated_f0_list);  f0_deviations = std(interpolated_f0_list);else  interpolated_f0 = temporal_positions * 0;  f0_deviations = temporal_positions * 0 + 1000;end;function event_struct = ZeroCrossingEngine(x, fs)negative_going_points =...  (1 : length(x))' .*...  (([x(2 : end) ; x(end)] .* x < 0) .* ([x(2 : end) ; x(end)] < x));edge_list = negative_going_points(negative_going_points > 0);fine_edge_list = edge_list - x(edge_list) ./ (x(edge_list + 1) - x(edge_list));event_struct.interval_locations =...  (fine_edge_list(1 : end - 1) + fine_edge_list(2 : end)) / 2 / fs;event_struct.interval_based_f0 = fs ./ diff(fine_edge_list);