function re = recode()[x, fs] = audioread('test-mwm.wav');lowest_f0=71;%display(x)negative_zero_cross = ZeroCrossingEngine(x, fs);#display(negative_zero_cross.interval_based_f0)positive_zero_cross = ZeroCrossingEngine(-x, fs);peak = ZeroCrossingEngine(diff(x), fs);dip = ZeroCrossingEngine(-diff(x), fs);frame_period = 5;temporal_positions = 0 : frame_period / 1000 : length(x) / fs;%display((temporal_positions));usable_channel =...  max(0, length(negative_zero_cross.interval_locations) - 2) *...  max(0, length(positive_zero_cross.interval_locations) - 2) *...  max(0, length(peak.interval_locations) - 2) *...  max(0, length(dip.interval_locations) - 2);  %display(negative_zero_cross.interval_locations);  if usable_channel > 0  interpolated_f0_list = zeros(4, length(temporal_positions));  interpolated_f0_list(1, :) =...    interp1(negative_zero_cross.interval_locations,...    negative_zero_cross.interval_based_f0, temporal_positions,...    'linear', 'extrap');  interpolated_f0_list(2, :) =...    interp1(positive_zero_cross.interval_locations,...    positive_zero_cross.interval_based_f0, temporal_positions,...    'linear', 'extrap');  interpolated_f0_list(3, :) = interp1(peak.interval_locations,...    peak.interval_based_f0, temporal_positions, 'linear', 'extrap');  interpolated_f0_list(4, :) = interp1(dip.interval_locations,...    dip.interval_based_f0, temporal_positions, 'linear', 'extrap');        interpolated_f0 = mean(interpolated_f0_list);    f0_deviations = std(interpolated_f0_list);  display(f0_deviations)else  interpolated_f0 = temporal_positions * 0;  f0_deviations = temporal_positions * 0 + 1000;end;%plot(temporal_positions, interpolated_f0);end;function event_struct = ZeroCrossingEngine(x, fs)negative_going_points =...  (1 : length(x))' .*...  (([x(2 : end) ; x(end)] .* x < 0) .* ([x(2 : end) ; x(end)] < x));edge_list = negative_going_points(negative_going_points > 0);fine_edge_list = edge_list - x(edge_list) ./ (x(edge_list + 1) - x(edge_list));event_struct.interval_locations =...  (fine_edge_list(1 : end - 1) + fine_edge_list(2 : end)) / 2 / fs;event_struct.interval_based_f0 = fs ./ diff(fine_edge_list);endrecode();